<!DOCTYPE html><html><head><title>JDK 源码分析 — Map</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style></style></head><body><div id='preview-contents' class='note-content'>



    <p></p>

    <h1 id="jdk-源码分析-map">JDK 源码分析 — Map</h1>

    <h2 id="hashmap">HashMap</h2>

    <p>HashMap采用的是哈希算法+链表冲突解决，table的大小永远为2次幂，因为在初始化的时候，会保证给定的初始容量为2次幂，如下：</p>



    <pre class="prettyprint hljs-dark"><code class="language-java hljs"><span class="hljs-comment">// Find a power of 2 &gt;= initialCapacity</span><br><span class="hljs-keyword">int</span> capacity = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (capacity &lt; initialCapacity)<br>    capacity &lt;&lt;= <span class="hljs-number">1</span>;<br></code></pre>

    <p>每一次扩展都为2的倍数，这样子的好处在于，计算HashCode之后，计算bucket index时就不需要进行求余运算，直接进行&amp;运算即可（如2^3 - 1 = 0x0111，进行&amp;运算就保证了在该值范围内，而不是2的次幂的话，就不行了，只能求余）</p>



    <pre class="prettyprint hljs-dark"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>{<br>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>}<br></code></pre>



    <h3 id="具体实现">具体实现</h3>



    <h4 id="put">put</h4>

    <p>put操作核心就在于先计算Hash找出对应的bucket，然后再看里面是否有对应的entry，如果没有，则新增，有则替换掉原来的值。在新增的过程中，如果判断出容量达到阈值，则要进行上述所讲的扩容。</p>



    <pre class="prettyprint hljs-dark"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>{<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 特殊处理，key为null的，放在bucket 0上</span><br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-comment">// 计算hash code</span><br>    <span class="hljs-keyword">int</span> hash = hash(key);<br>    <span class="hljs-comment">// 计算bucket index</span><br>    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);<br>    <span class="hljs-comment">// 查找是否有值</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) {<br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {<br>            V oldValue = e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        }<br>    }<br><br>    <span class="hljs-comment">// 没有则结构变更，modCount加1</span><br>    modCount++;<br>    <span class="hljs-comment">// 添加entry</span><br>    addEntry(hash, key, value, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>{<br>    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-keyword">null</span> != table[bucketIndex])) {<br>        <span class="hljs-comment">// 达到阈值，并且当前有冲突才会进行rehashing</span><br>        <span class="hljs-comment">// 2倍的速度增长</span><br>        resize(<span class="hljs-number">2</span> * table.length);<br>        hash = (<span class="hljs-keyword">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;<br>        bucketIndex = indexFor(hash, table.length);<br>    }<br><br>    <span class="hljs-comment">// 添加新的entry</span><br>    createEntry(hash, key, value, bucketIndex);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>{<br>    Entry&lt;K,V&gt; e = table[bucketIndex];<br>    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);<br>    size++;<br>}<br></code></pre>



    <h4 id="resize">resize</h4>

    <p>重新哈希（rehashing），条件是<code>(size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])</code>，达到阈值并且产生冲突。如果新容量大于设定的Hash算法切换阈值，有可能会切换Hash算法，这时Hash Code就要进行重新计算。</p>



    <pre class="prettyprint hljs-dark"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>{<br>    Entry[] oldTable = table;<br>    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;<br>    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) {<br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    Entry[] newTable = <span class="hljs-keyword">new</span> Entry[newCapacity];<br>    <span class="hljs-keyword">boolean</span> oldAltHashing = useAltHashing;<br>    <span class="hljs-comment">// 这里当虚拟机启动后，并且新的容量大于设定切换Hash的阈值，则切换Hash</span><br>    useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;<br>            (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);<br>    <span class="hljs-comment">/* 这里的rehash指示是否需要重新计算HashCode，只有当Hash算法进行切换的时候才需要重新计算，<br>    如果已经切换过来了，则不需要了 */</span><br>    <span class="hljs-keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;<br>    transfer(newTable, rehash);<br>    table = newTable;<br>    threshold = (<span class="hljs-keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>}<br></code></pre>



    <h3 id="transfer">transfer</h3>

    <p>将entry转移到新的table表里面</p>



    <pre class="prettyprint hljs-dark"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-keyword">boolean</span> rehash)</span> </span>{<br>    <span class="hljs-keyword">int</span> newCapacity = newTable.length;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) {<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) {<br>            Entry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-comment">// 这里就是指示是否需要重新计算HashCode</span><br>            <span class="hljs-keyword">if</span> (rehash) {<br>                e.hash = <span class="hljs-keyword">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);<br>            }<br>            <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);<br>            e.next = newTable[i];<br>            newTable[i] = e;<br>            e = next;<br>        }<br>    }<br>}<br></code></pre>



    <h4 id="get">get</h4>

    <p>get相对比较简单，计算Hash，定位到对应的bucket，然后再从bucket的链表中查找。</p>



    <pre class="prettyprint hljs-dark"><code class="language-java` hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>{<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> getForNullKey();<br>    Entry&lt;K,V&gt; entry = getEntry(key);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == entry ? <span class="hljs-keyword">null</span> : entry.getValue();<br>}<br><br><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; getEntry(Object key) {<br>    <span class="hljs-comment">// 计算Hash code</span><br>    <span class="hljs-keyword">int</span> hash = (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : hash(key);<br>    <span class="hljs-comment">// 定位到对应的bucket</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];<br>         e != <span class="hljs-keyword">null</span>;<br>         e = e.next) {<br>        <span class="hljs-comment">// 循环，依次查找</span><br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> e;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>}<br></code></pre>



    <h2 id="linkedhashmap">LinkedHashMap</h2>

    <p>LinkedHashMap，一般用于在使用HashMap的时候，需要记录每个entry的插入顺序或者访问顺序（如LRU，FIFO）。在HashMap的基础上实现还是比较简单的，只需要自定义一个entry，继承HashMap的entry，在里面添加链表的特性，然后再覆盖对应的addEntry，使用自定义的entry即可。 <br>
        关键字段： <br>
        accessOrder：用于控制节点排序为访问顺序还是插入的顺序，accessOrder=false可以实现FIFO的淘汰策略，accessOrder=true实现LRU，默认为false。</p>



    <h3 id="具体实现-1">具体实现</h3>



    <h4 id="put-1">put</h4>

    <p>put操作，通过对addEntry以及createEntry的方法来进行追加链表特性。</p>



    <pre class="prettyprint hljs-dark"><code class="language-java hljs"><span class="hljs-comment">// put操作当需要添加entry时，会调用此addEntry方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>{<br><br>    <span class="hljs-comment">// 调用父类的实现，不作更改</span><br>    <span class="hljs-keyword">super</span>.addEntry(hash, key, value, bucketIndex);<br><br>    <span class="hljs-comment">// 当有必要的时候，会移除一些键值（通过覆盖removeEldestEntry方法来实现）</span><br>    Entry&lt;K,V&gt; eldest = header.after;<br>    <span class="hljs-keyword">if</span> (removeEldestEntry(eldest)) {<br>        <span class="hljs-comment">/* 移除最老的键值对，这里最老的键值对判断方式由子类实现，<br>        但是顺序由accessOrder实现，可以为LRU或者FIFO */</span><br>        removeEntryForKey(eldest.key);<br>    }<br>}<br><br><span class="hljs-comment">// 父类的entry会调用到此方法（因为覆盖了）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>{<br>    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];<br>    <span class="hljs-comment">// 覆盖父类的createEntry是为了使用当前类定义的entry，具有链表的特性</span><br>    Entry&lt;K,V&gt; e = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, old);<br>    table[bucketIndex] = e;<br>    e.addBefore(header);<br>    size++;<br>}<br></code></pre>



    <h4 id="get-1">get</h4>

    <p>Get操作也是覆盖了父类的实现，方便访问后调用子类的recordAccess。</p>



    <pre class="prettyprint hljs-dark"><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>{<br>    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 访问回调</span><br>    e.recordAccess(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> e.value;<br>}<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>{<br>    Entry&lt;K,V&gt; before, after;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recordAccess</span><span class="hljs-params">(HashMap&lt;K,V&gt; m)</span> </span>{<br>        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;<br>        <span class="hljs-comment">// 这里accessOrder为false则不调整顺序</span><br>        <span class="hljs-keyword">if</span> (lm.accessOrder) {<br>            <span class="hljs-comment">// true则将当前访问的节点移动到的链表头</span><br>            lm.modCount++;<br>            remove();<br>            addBefore(lm.header);<br>        }<br>    }<br>}<br></code></pre>



    <h4 id="hashtable">Hashtable</h4>

    <p>Hashtable和HashMap的区别：</p>

    <ol><li rel="1">Hashtable的基本操作采用同步实现，加了synchronized关键字</li>
        <li rel="2">扩容策略，可以指定初始大小，后续以这个基础进行扩容，每次均为当前数值两倍（不一定是2次幂，采用求余运算）</li>
        <li rel="3">取所有的key或者values时，返回的是Enumeration（也有keySet操作）</li>
    </ol></div></body></html>
